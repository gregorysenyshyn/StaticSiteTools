#!/usr/bin/env python3
import os
import glob
import time
import shutil
import itertools
import subprocess
import json

from jinja2 import BaseLoader
from jinja2 import Environment
from jinja2 import DebugUndefined

import yaml
import sass
import mistune
from mistune.directives import RSTDirective, TableOfContents
import frontmatter


# ####### #
#  UTILS  #
# ####### #


class GlobLoader(BaseLoader):
    '''
    Uses glob from standard library to load files. Paths can be excluded by
    prepending an exclamation mark. Path expansion with ** works in Python 3.5+
    '''

    def __init__(self, paths):
        '''
        paths must be a list
        '''
        files = [self.concat_paths(item) for item in paths]
        self.files = list(itertools.chain.from_iterable(files))

    @classmethod
    def concat_paths(cls, paths_to_concat):
        '''
        Concatenates paths from lists or named individually
        '''
        positive_match = []
        negative_match = []
        if isinstance(paths_to_concat, list):
            for item in paths_to_concat:
                cls.append_path_to_list(item, positive_match, negative_match)
        elif isinstance(paths_to_concat, str):
            cls.append_path_to_list(paths_to_concat,
                                    positive_match,
                                    negative_match)
        return list(set(positive_match) - set(negative_match))

    @staticmethod
    def append_path_to_list(path_to_append, positive_match, negative_match):
        '''
        Sorts paths into positive and negative matches with correct path names
        '''
        if path_to_append.startswith('!'):
            negative_match += glob.glob(path_to_append[1:])
        else:
            positive_match += glob.glob(path_to_append)

    def get_source(self, environment, template):
        for item in self.files:
            if os.path.basename(item) == template:
                mtime = os.path.getmtime(item)
                with open(item, 'r') as f:
                    return (f.read(),
                            item,
                            lambda: mtime == os.path.getmtime(item))


def search_include_paths(target_filename, include_paths):
    for include_path in include_paths:
        search_file = os.path.join(include_path, target_filename)
        if os.path.isfile(search_file):
            return search_file
    raise FileNotFoundError(f"Can't find {target_filename}")


def concat_files(glob_paths, include_paths=None):
    '''Takes a list of filenames and combines the contents of those files into
    one string
    '''
    files = []
    for path in glob_paths:
        globbed_paths = glob.glob(path)
        if globbed_paths:
            for file in globbed_paths:
                if os.path.isfile(file):
                    files.append(file)
        elif include_paths:
            files.append(search_include_paths(path, include_paths))
        else:
            raise FileNotFoundError("Can't find {0}".format(path))
    return_string = ''
    for current_file in files:
        with open(current_file, 'r') as f:
            return_string += f.read()
    return return_string


def clean(path):
    '''Delete files generated by build script'''
    for root, dirs, files in os.walk(os.path.expanduser(path)):
        for f in files:
            os.unlink(os.path.join(root, f))
        for d in dirs:
            if os.path.islink(os.path.join(root, d)):
                os.unlink(os.path.join(root, d))
            else:
                shutil.rmtree(os.path.join(root, d))


def copy_files(files_to_copy):
    for dest_path in files_to_copy:
        if not os.path.exists(dest_path):
            os.makedirs(dest_path)
        file_list = GlobLoader(files_to_copy[dest_path]).files
        for file in file_list:
            print((f'Copying {os.path.basename(file)} to {dest_path}'
                   '...'),
                  end="")
            if os.path.isfile(file):
                shutil.copyfile(file, os.path.join(dest_path,
                                                   os.path.basename(file)))
                print(' Done!')
            elif os.path.isdir(file):
                shutil.copytree(file, os.path.join(dest_path,
                                                   os.path.basename(file)))
                print(' Done!')



def link_static(src, dest):
    print((f'linking {src} to {dest}...'), end='')
    subprocess.run(['ln', '-s',
                    os.path.expanduser(src),
                    os.path.expanduser(dest)])
    print(' Done!')


# #### #
#  JS  #
# #### #


def handle_js(data, dest_path):
    t1 = time.time()
    print(f'{time.asctime()} — Generating {dest_path}...', end="")
    js_string = ''
    js_string = concat_files(data['js']['paths'][dest_path],
                             data['js']['search'])
    os.makedirs(os.path.join(data['options']['dist'],
                             os.path.split(dest_path)[0]),
                exist_ok=True)
    with open(os.path.join(data['options']['dist'], dest_path), 'w') as f:
        f.write(js_string)
    print(' Done in {0} seconds'.format(round(float(time.time() - t1), 4)))


# ###### #
#  CSS   #
# ###### #


def handle_scss(data, dest_path):
    t1 = time.time()
    print(f'{time.asctime()} — Generating {dest_path}...', end="")
    scss_string = concat_files(data['scss']['paths'][dest_path],
                               data['scss']['search'])
    os.makedirs(os.path.join(data['options']['dist'],
                             os.path.split(dest_path)[0]),
                exist_ok=True)
    with open(os.path.join(data['options']['dist'], dest_path), 'w') as f:
        f.write(sass.compile(string=scss_string))
    print(' Done in {0} seconds'.format(round(float(time.time() - t1), 4)))

# ######### #
#   AUDIO   #
# ######### #


def handle_audio(options):
    if 'audio' in options:
        local_images = os.path.join(os.getcwd(),
                                    options['audio'])
        image_dest = options['dist']
        print((f'linking {local_images} to {image_dest}...'), end='')
        subprocess.run(['ln', '-s', local_images, image_dest])
    print(' Done!')


# ###### #
#  HTML  #
# ###### #


def markdown_filter(text):
    markdown = mistune.create_markdown(
    plugins=[RSTDirective([TableOfContents()])])
    return markdown(text)


def get_j2_env(pageset):
    template_files = [pageset[pathset] for pathset in pageset
                      if pathset in ['partials', 'layouts']]
    j2_env = Environment(loader=GlobLoader(template_files), trim_blocks=True)
    j2_env.filters['markdown'] = markdown_filter
    return j2_env


def get_destination(page, dest, file_ext=True):
    '''
    Joins dest to the name of the page, and replaces file extension with .html
    '''
    basename = os.path.basename(page)
    final_name = os.path.splitext(basename)[0]
    if not file_ext:
        return os.path.join(dest, f'{final_name}')
    else:
        return os.path.join(dest, f'{final_name}.html')


def get_nav_pages(files, options):
    nav_pages = []

    for fileset in files:
        fileset_pages = []
        if isinstance(fileset['src'], str):
            fileset_pages.append(fileset['src'])
        elif isinstance(fileset['src'], list):
            current_pages = GlobLoader.concat_paths(fileset['src'])
            for glob_page in current_pages:
                fileset_pages.append(glob_page)
        for page_name in fileset_pages:
            page = {'src': page_name,
                    'dest': get_destination(page_name, fileset['dest'], False)}
            set_page_metadata(page)
            if page['data'].get('nav_item'):
                (print("yes nav: ", page['src']))
                nav_data = {}
                nav_data['title'] = page['data'].get('title')
                nav_data['dest'] = page.get('dest')
                nav_data['order'] = page['data'].get('order')
                nav_data['subtitle'] = page['data'].get('subtitle')
                nav_data['nav_category'] = page['data'].get('nav_category')
                nav_pages.append(nav_data)

    nav_pages = sorted(nav_pages, key=lambda x: x['order'])
    return nav_pages


def set_page_metadata(page, index=False):
    '''
    Sets metadata, including dest, content, data
    '''
    if page['src'].endswith('.yaml'):
        with open(page['src'], 'r') as f:
            page['data'] = yaml.load(f, Loader=yaml.SafeLoader)

    elif page['src'].endswith('.md') or page['src'].endswith('.html'):
        fm_page = frontmatter.load(page['src'])
        page['data'] = fm_page.metadata
        # if not index:
        page['content'] = fm_page.content
    else:
        print(f"{page['src']} must be in either .yaml,"
              ' .md or .html (jinja2) format!')


def get_page(src, dest, template):
    page = ({'src': src,
             'dest': get_destination(src, dest),
             'template': template})
    set_page_metadata(page)
    return page


def get_pages(files, options):
    '''
    Returns a list containing one or more dicts of page data
    '''
    if isinstance(files, dict):
        files = [files]

    pages = []
    for fileset in files:
        current_filenames = GlobLoader.concat_paths(fileset['src'])

        for filename in current_filenames:
            page = get_page(filename,
                            fileset['dest'],
                            fileset['template'])
            pages.append(page)

    return pages


def build_page(page, j2_env, options):

    page_time = time.time()
    print(f'{time.asctime()} — Building {page["src"]}...', end='')

    if 'content' in page:
        final_page = j2_env.from_string(page['content']).render(page['data'])
    else:
        template = j2_env.get_template(page['template'])
        final_page = template.render(page['data'])

    local_path = os.path.join(options['dist'], os.path.dirname(page['dest']))
    os.makedirs(local_path, exist_ok=True)

    with open(os.path.join(options['dist'], page['dest']), 'w') as f:
        f.write(final_page)
    print(f' Done writing {page["dest"]} in '
          f'{round(float(time.time() - page_time), 4)} seconds')


def build_pageset(pageset, options):
    '''Logic for building pages.'''

    if pageset['options'].get('nav'):
        nav_pages = get_nav_pages(pageset['files'], options)

    pages = get_pages(pageset['files'], options)
    j2_env = get_j2_env(pageset)
    for page in pages:

        # global options
        page['data']['analytics_id'] = options.get('analytics_id')
        page['data']['google_ads_id'] = options.get('google_ads_id')
        page['data']['recaptcha_sitekey'] = options.get('recaptcha_sitekey')
        page['data']['api_url'] = options.get('api_url')
        page['data']['images_url'] = options.get('images_url')
        page['data']['stripe_publishable_key'] = options.get('stripe_publishable_key')

        # GLOBAL STRIPE OVERRIDE FOR DEV
        global_price_id = options.get('global_stripe_price_id')
        if global_price_id:
            # Override top-level price ID if it exists
            if page['data'].get('stripe_price_id'):
                page['data']['stripe_price_id'] = global_price_id

            # Override enroll_banner price IDs
            if page['data'].get('enroll_banner'):
                for item in page['data']['enroll_banner']:
                    if item.get('stripe_price_id'):
                        item['stripe_price_id'] = global_price_id

        if options.get('production'):
            page['data']['production'] = True

        # pageset options
        if 'nav' in pageset['options']:
            page['data']['nav_pages'] = nav_pages

        build_page(page, j2_env, options)


def build_emails(data):
    """Builds email templates from src/emails."""
    print(f"\n{time.asctime()} — Building Emails...")

    # We iterate over environments found in src/emails/
    # Expected structure: src/emails/dev/*.html, src/emails/prod/*.html
    email_root = 'src/emails'
    template_root = 'email_templates'

    if not os.path.exists(email_root):
        print(f"Warning: {email_root} not found. Skipping email build.")
        return

    # Setup Jinja Environment for Emails (Layouts and Partials are shared)
    # GlobLoader requires glob patterns, not just directory names
    template_paths = [
        'src/layouts/*.html',
        'src/partials/*.html',
        'src/partials/email/*.html'
    ]
    # Use DebugUndefined to preserve {{ variables }} for the backend to fill
    j2_env = Environment(
        loader=GlobLoader(template_paths),
        trim_blocks=True,
        undefined=DebugUndefined
    )

    # Walk through subdirectories (environments) in src/emails
    for env in ['dev', 'prod']:
        src_dir = os.path.join(email_root, env)
        dest_dir = os.path.join(template_root, env)

        if not os.path.exists(src_dir):
            continue

        print(f"  Processing environment: {env}...")
        os.makedirs(dest_dir, exist_ok=True)

        email_files = glob.glob(os.path.join(src_dir, '*.html'))

        for email_file in email_files:
            filename = os.path.basename(email_file)
            print(f"    Building {filename}...", end="")

            try:
                # Read source content
                with open(email_file, 'r') as f:
                    content = f.read()

                # Create a template from the content
                template = j2_env.from_string(content)

                # Render with empty context
                rendered_html = template.render()

                # Write to destination
                dest_path = os.path.join(dest_dir, filename)
                with open(dest_path, 'w') as f:
                    f.write(rendered_html)

                print(" Done!")

            except Exception as e:
                print(f" Failed: {e}")


def generate_test_pages(data, options):
    """Generates test pages for forms defined in test_forms."""
    print(f"\n{time.asctime()} — Generating Test Pages...")
    test_forms = data.get('test_forms', [])
    if not test_forms:
        print("No test_forms found.")
        return

    dist_test_dir = os.path.join(options['dist'], '_test')
    os.makedirs(dist_test_dir, exist_ok=True)

    generated_pages = []

    for form in test_forms:
        form_name = form['name']
        partial_path = form['partial']
        css_files = form.get('css', [])
        js_files = form.get('js', [])
        context = form.get('context', {}).copy()
        prefill = form.get('prefill', {})

        # Merge global options into context
        context['api_url'] = options.get('api_url')
        context['images_url'] = options.get('images_url')
        context['recaptcha_sitekey'] = options.get('recaptcha_sitekey')
        context['stripe_publishable_key'] = options.get('stripe_publishable_key')

        # GLOBAL STRIPE OVERRIDE FOR TEST PAGES
        global_price_id = options.get('global_stripe_price_id')
        if global_price_id:
             # Check context for enroll_banner or direct price_id
             if context.get('stripe_price_id'):
                 context['stripe_price_id'] = global_price_id

             if context.get('enroll_banner'):
                for item in context['enroll_banner']:
                    if item.get('stripe_price_id'):
                        item['stripe_price_id'] = global_price_id

        print(f"  Generating test page for: {form_name}")

        # Load partial content
        if not os.path.exists(partial_path):
             print(f"    Error: Partial {partial_path} not found.")
             continue

        # Create a Jinja2 environment for the partial
        # We assume the partial might reference other templates, so we use the directory of the partial
        partial_dir = os.path.dirname(os.path.abspath(partial_path))
        j2_env = Environment(loader=GlobLoader([partial_dir]), trim_blocks=True)

        try:
            template = j2_env.from_string(open(partial_path).read())
            rendered_partial = template.render(context)
        except Exception as e:
            print(f"    Error rendering partial {partial_path}: {e}")
            continue

        # Generate slug for filename
        slug = form_name.lower().replace(' ', '-')
        filename = f"{slug}.html"
        filepath = os.path.join(dist_test_dir, filename)

        # Build CSS links
        css_links = ""
        for css in css_files:
             # Ensure CSS path is relative to the test page or absolute
             # Since test pages are in /_test/, and css is likely in /css/, we need ../css/
             # or just use /css/ if served from root. Let's assume /css/ for simplicity if deployed
             # but for local file viewing, relative is better.
             # Actually, options['dist'] structure implies assets are at root of dist.
             # So from _test/ we need ../
             link_path = f"../{css}"
             css_links += f'<link rel="stylesheet" href="{link_path}">\n'

        # Build JS links
        js_links = ""
        for js in js_files:
             script_path = f"../{js}"
             js_links += f'<script src="{script_path}" defer></script>\n'

        # Build Prefill Script
        prefill_json = json.dumps(prefill)
        prefill_script = f"""
        <script>
            document.addEventListener("DOMContentLoaded", function() {{
                const prefillData = {prefill_json};
                console.log("Prefilling form with:", prefillData);

                for (const [key, value] of Object.entries(prefillData)) {{
                    const inputs = document.querySelectorAll(`[name="${{key}}"], [id="${{key}}"]`);
                    inputs.forEach(input => {{
                        if (input.type === 'checkbox' || input.type === 'radio') {{
                            if (input.value === value.toString() || value === true) {{
                                input.checked = true;
                            }}
                        }} else {{
                            input.value = value;
                        }}
                    }});
                }}
            }});
        </script>
        """

        # Build Full HTML
        html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test: {form_name}</title>
    <script src="https://www.google.com/recaptcha/enterprise.js?render={context['recaptcha_sitekey']}" async defer></script>
    {css_links}
    {js_links}
    <style>
        body {{ background-color: #f4f4f4; padding: 20px; }}
        .test-wrapper {{ background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); max-width: 800px; margin: 0 auto; }}
        .test-header {{ text-align: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 10px; }}
    </style>
</head>
<body>
    <div class="test-wrapper">
        <div class="test-header">
            <h1>Test Mode: {form_name}</h1>
            <p><a href="index.html">&larr; Back to Test Index</a></p>
        </div>
        <div class="test-content">
            {rendered_partial}
        </div>
    </div>
    {prefill_script}
</body>
</html>
        """

        with open(filepath, 'w') as f:
            f.write(html_content)

        generated_pages.append({'name': form_name, 'file': filename})

    # Generate Index Page
    index_path = os.path.join(dist_test_dir, 'index.html')
    index_list_items = ""
    for page in generated_pages:
        link = page["file"].replace(".html", "")
        index_list_items += f'<li><a href="{link}">{page["name"]}</a></li>\n'

    index_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Forms Index</title>
    <style>
        body {{ font-family: sans-serif; padding: 40px; background: #f0f0f0; }}
        .container {{ background: white; padding: 40px; border-radius: 8px; max-width: 600px; margin: 0 auto; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }}
        h1 {{ margin-top: 0; }}
        ul {{ line-height: 1.6; }}
        a {{ text-decoration: none; color: #007bff; font-weight: bold; }}
        a:hover {{ text-decoration: underline; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Form Verification Mode</h1>
        <p>Select a form to verify in the Dev environment.</p>
        <ul>
            {index_list_items}
        </ul>
    </div>
</body>
</html>
    """

    with open(index_path, 'w') as f:
        f.write(index_content)

    print(f"Generated {len(generated_pages)} test pages and index.")
