import os
import glob
import json
import argparse
import datetime

import boto3
from botocore.exceptions import ClientError


def handle_page(filename, destname, options, client=None):
    if client is None:
        client = get_client(options, 's3')
    extra_args = {'CacheControl': f'max-age={options["cache_control_age"]}',
                  'ContentType': 'text/html'}
    upload_file(filename, destname, extra_args, options, client)


def handle_css(filename, destname, options, client=None):
    if client is None:
        client = get_client(options, 's3')
    extra_args = {'CacheControl': f'max-age={options["cache_control_age"]}',
                  'ContentType': 'text/css'}
    upload_file(filename, destname, extra_args, options, client)


def handle_js(filename, destname, options, client=None):
    if client is None:
        client = get_client(options, 's3')
    extra_args = {'CacheControl': f'max-age={options["cache_control_age"]}',
                  'ContentType': 'text/javascript'}
    upload_file(filename, destname, extra_args, options, client)


def handle_image(filename, destname, options, client=None):
    if client is None:
        client = get_client(options, 's3')
    extra_args = {'CacheControl': f'max-age={options["cache_control_age"]}'}
    if filename.endswith('.svg'):
        extra_args['ContentType'] = 'image/svg+xml'
    elif filename.endswith('.jpg') or filename.endswith('jpeg'):
        extra_args['ContentType'] = 'image/jpeg'
    elif filename.endswith('.png'):
        extra_args['ContentType'] = 'image/png'
    elif filename.endswith('.gif'):
        extra_args['ContentType'] = 'image/gif'
    upload_file(filename, destname, extra_args, options, client)


def get_cloudfront_config(options, endpoint, oai,
                          cert_arn, index_name='index'):
    return {'CallerReference': str(datetime.datetime.now()),
            'Aliases': {
                'Quantity': 2,
                'Items': [
                    options['s3_bucket'],
                    f"www.{options['s3_bucket']}",
                ]
            },
            "Origins": {
                "Quantity": 1,
                "Items": [
                    {"DomainName": endpoint,
                     'Id': f'S3-{options["s3_bucket"]}',
                     "S3OriginConfig": {
                         "OriginAccessIdentity": ("origin-access-identity/"
                                                  f"cloudfront/{oai['Id']}")}}
                ]},
            "Comment": 'Autogenerated',
            "Enabled": True,
            "DefaultRootObject": index_name,
            "DefaultCacheBehavior": {
                "TargetOriginId":  f'S3-{options["s3_bucket"]}',
                'TrustedSigners': {'Enabled': False, 'Quantity': 0},
                'ViewerProtocolPolicy': 'redirect-to-https',
                'MinTTL': 300,
                'AllowedMethods': {
                    'Quantity': 3,
                    'Items': ['GET', 'HEAD', 'OPTIONS']},
                "ForwardedValues": {
                    "QueryString": False,
                    "Cookies": {"Forward": "none"}
                    },
                },
            "PriceClass": "PriceClass_All",
            "ViewerCertificate": {"CloudFrontDefaultCertificate": False,
                                  "ACMCertificateArn": cert_arn,
                                  "SSLSupportMethod": "sni-only"}
            }


def create_cname_record(options, validation, zone):
    r53_client = get_client(options, 'route53')
    response = r53_client.change_resource_record_sets(
            HostedZoneId=zone['Id'],
            ChangeBatch={'Comment': 'Autogenerated by SST/s3.py!',
                'Changes': [{
                 'Action': 'UPSERT',
                 'ResourceRecordSet': {
                    'Name': validation['ResourceRecord']['Name'],
                    'Type': 'CNAME',
                    'TTL': 15,
                    'ResourceRecords': [{'Value': (validation['ResourceRecord']
                                         ['Value'])}]}}]})
    waiter = r53_client.get_waiter('resource_record_sets_changed')
    waiter.wait(Id=response['ChangeInfo']['Id'])
    check_dns(options, validation)


def check_dns(options, validation):
    r53_client = get_client(options, 'route53')
    zones = r53_client.list_hosted_zones()
    for zone in zones['HostedZones']:
        if str(zone['Name']).startswith(options['s3_bucket']):
            record = r53_client.test_dns_answer(HostedZoneId=zone['Id'],
                       RecordName=validation['ResourceRecord']['Name'],
                       RecordType='CNAME')
            if len(record['RecordData']) < 1:
                record_q = ('No CNAME Validation Record Found.'
                            '  Create one (y/n)? ')
                record_a = input(record_q)
                if record_a == 'y':
                    create_cname_record(options, validation, zone)
                else:
                    raise SystemExit('DNS-Validated Certificate'
                                     ' needed to continue')
            else:
                if record['ResponseCode'] == 'NOERROR':
                    print('DNS Validation CNAME Record: No Error')
                    return 0


def check_certificate(options, cert_arn):
    acm_client = get_client(options, 'acm')
    certificate = acm_client.describe_certificate(CertificateArn=cert_arn)
    if 'DomainValidationOptions' not in certificate['Certificate']:
        # Crashed because DomainValidationOptions not in certificate yet??
        import pdb; pdb.set_trace()
    for item in certificate['Certificate']['DomainValidationOptions']:
        if str(item['DomainName']).endswith(options['s3_bucket']):
            if item['ValidationStatus'] is not 'SUCCESS':
                dns_q = (f'{certificate["Certificate"]["CertificateArn"]}'
                         f' status is {item["ValidationStatus"]}. Check DNS '
                         '(y/n)? ')
                dns_check = input(dns_q)
                if dns_check == 'y':
                    if check_dns(options, item) == 0:
                        wait_q = 'Continue to wait for validation (y/n)? '
                        wait_a = input(wait_q)
                        if wait_a == 'y':
                            waiter = acm_client.get_waiter(
                                                       'certificate_validated')
                            waiter.wait(CertificateArn=cert_arn)
                else:
                    raise SystemExit('Valid Certificate Needed to Proceed.')


def get_acm_certificate(options):
    client = get_client(options, 'acm')
    cert_list = client.list_certificates()
    if len(cert_list['CertificateSummaryList']) == 0:
        cert_arn = request_acm_certificate(options)
        return cert_arn
    else:
        for item in cert_list['CertificateSummaryList']:
            if str(item['DomainName']).endswith(options['s3_bucket']):
                return item['CertificateArn']


def request_acm_certificate(options):
    client = get_client(options, 'acm')
    cert_arn = client.request_certificate(
            DomainName=f'*.{options["s3_bucket"]}', ValidationMethod='DNS')
    return cert_arn['CertificateArn']


def create_oai(cf_client, options):
    oai = cf_client.create_cloud_front_origin_access_identity(
            CloudFrontOriginAccessIdentityConfig={
                'CallerReference': str(datetime.datetime.now()),
                'Comment': options['s3_bucket']})
    return oai


def get_oai(cf_client, options):
    oai = None
    oai_list = cf_client.list_cloud_front_origin_access_identities()
    if not oai_list['CloudFrontOriginAccessIdentityList']['IsTruncated']:
        if 'Items' in oai_list['CloudFrontOriginAccessIdentityList']:
            for item in oai_list['CloudFrontOriginAccessIdentityList']['Items']:
                if item['Comment'] == options['s3_bucket']:
                    oai = item
                else:
                    oai = create_oai(cf_client, options)
        else:
            oai_answer = input('No OAI found.  Create one? (y/n) ')
            if oai_answer == 'y':
                oai = create_oai(cf_client, options)
            else:
                raise SystemExit('No Origin Access Identities!'
                                 ' Can\'t set up distribution')
    else:
        raise SystemExit('OAI Results Truncated!'
                         ' Implement more functionality to proceed!')
    return oai


def create_cdn_distribution(options):
    s3_client = get_client(options, 's3')
    response = s3_client.get_bucket_location(Bucket=options['s3_bucket'])
    zone = response['LocationConstraint']
    endpoint = f'{options["s3_bucket"]}.s3.{zone}.amazonaws.com'

    cf_client = get_client(options, 'cloudfront')
    oai = get_oai(cf_client, options)
    cert_arn = get_acm_certificate(options)
    print(cert_arn)
    check_certificate(options, cert_arn)
    # cf_config = get_cloudfront_config(options, endpoint, oai, cert_arn)
    # response = cf_client.create_distribution(DistributionConfig=cf_config)
    # return response['Distribution']['ARN']


def check_cdn_distribution(options):
    client = get_client(options, 'cloudfront')
    distribution_arn = ''
    response = client.list_distributions()
    if response['DistributionList']['Quantity'] == 0:
        print('No distributions found! Create one? (y/n) ', end='')
        create = input()
        if create == 'y':
            distribution_arn = create_cdn_distribution(options)
            return distribution_arn
        else:
            raise SystemExit('No distributions!')
    else:
        print(response['DistributionList'])


def get_bucket_policy(options):
    bucket_policy = {
        'Version': '2012-10-17',
        'Statement': [{
            'Sid': 'AddPerm',
            'Effect': 'Allow',
            'Principal': '*',
            'Action': ['s3:GetObject'],
            f'Resource': f'arn:aws:s3:::{options["s3_bucket"]}/*'
        }]
    }
    return json.dumps(bucket_policy)


def check_bucket_policy(options, client=None):
    if client == None:
        client = get_client(options, 's3')
    print('\nChecking Bucket Policy')
    response = client.get_bucket_policy_status(Bucket=options['s3_bucket'])
    if response['PolicyStatus']['IsPublic']:
        print(f'{options["s3_bucket"]} is public')
    else:
        print(f'{options["s3_bucket"]} is NOT public')
        response = client.get_bucket_policy(Bucket=options['s3_bucket'])
        print(f'Policy:\n{response["Policy"]}')
        new_policy = input('Reset bucket policy? (y/n) ', end='')
        if new_policy == 'y':
            client.put_bucket_policy(Bucket=options['s3_bucket'],
                                     Policy=get_bucket_policy())


def set_up_website(options, client=None, index_name='index', error_name='error'):
    if client == None:
        client = get_client(options, 's3')
    print('\nSetting up website... ')
    client.put_bucket_website(
        Bucket=options['s3_bucket'],
        WebsiteConfiguration={
            'IndexDocument': {'Suffix': index_name},
            'ErrorDocument': {'Key': error_name}
        })
    response = client.get_bucket_website(Bucket=options['s3_bucket'])
    check_index_and_error_pages(response, options)


def check_index_and_error_pages(response, options):
    update = False
    dist_files = os.listdir(options['dist'])

    index_document = ''
    if 'IndexDocument' in response:
        index_document = response['IndexDocument']['Suffix']
        print(f'Index Document "{index_document}": ', end='')
        if f'{index_document}.html' in dist_files:
            print('Exists!')
        else:
            print("Doesn't Exist!")
    else:
        index_response = input('Error document not set.  Set it now? (y/n) ')
        if index_response == 'y':
            update = True
            print('\n')
            for (dirpath, dirnames, filenames) in os.walk(options['dist']):
                for filename in filenames:
                    print(filename)
            index_document = input(('Which file? (exclude'
                                    ' file extension for pretty urls) '))

    error_document = ''
    if 'ErrorDocument' in response:
        error_document = response['ErrorDocument']['Key']
        print(f'Error Document "{error_document}": ', end='')
        if f'{error_document}.html' in dist_files:
            print('Exists!')
        else:
            print("Doesn't Exist!")
    else:
        error_response = input('Error document not set.  Set it now? (y/n) ')
        if error_response == 'y':
            update = True
            print('\n')
            for (dirpath, dirnames, filenames) in os.walk(options['dist']):
                for filename in filenames:
                    print(filename)
            error_document = input(('\nWhich file? (exclude'
                                    ' file extension for pretty urls) '))
    if update == True:
        set_up_website(options,
                       index_name=index_document,
                       error_name=error_document)


def confirm_website_settings(options, client=None):
    if client == None:
        client = get_client(options, 's3')
    bucket = options['s3_bucket']
    try:
        response = client.get_bucket_website(Bucket=bucket)
    except ClientError:
        print('ERROR: no website config\nSet up website? (y/n)', end='')
        answer = input()
        if answer == 'y':
            index_name = ('Index page name? (index): ')
            if index_name == '':
                index_name = 'index'
            error_name = ('Error page name? (error): ')
            if error_name == '':
                error_name = 'error'
            set_up_website(options, client=client,
                           index_name=index_name, error_name=error_name)
    else:
        check_index_and_error_pages(response, options)


def upload_file(filename, destname, extra_args, options, client=None):
    client = get_client(options, 's3')
    print(f'Copying {filename} to {options["s3_bucket"]}/{destname}...',
          end='')
    with open(filename, 'rb') as f:
        client.upload_fileobj(f,
                              options['s3_bucket'],
                              destname,
                              ExtraArgs=extra_args)
    print(' Done!')


def send_it(options, client=None):
    if client == None:
        client = get_client(options, 's3')
    for filename in glob.glob(f'{options["dist"]}/**', recursive=True):
        if not filename.startswith('.'):
            if not os.path.isdir(filename):
                destname = filename[len(options['dist'])+1:]
                if destname.endswith('.html'):
                    destname = destname[:-5]
                    handle_page(filename, destname, options, client)
                elif destname.startswith('js/') and destname.endswith('.js'):
                    handle_js(filename, destname, options, client)
                elif destname.startswith('css/') and destname.endswith('.css'):
                    handle_css(filename, destname, options, client)
                elif destname.startswith('images/'):
                    pass
                #subprocess.run(['aws', 's3', 'sync',
                #    ##TODO os.path.join?
                #               options['dist'],
                #               f's3://{options["s3_bucket"]}',
                #               '--delete'])
        else:
            print(f'ERROR - Not uploading hidden file {filename}')


def clean(options, images=False, client=None):
    if client == None:
        client = get_client(options, 's3')
    response = client.list_objects(Bucket=options['s3_bucket'])
    if 'Contents' in response:
        for item in response['Contents']:
            if not item['Key'].startswith(options['images']) or images == True:
                print(f'removing {item["Key"]}... ', end='')
                client.delete_object(Bucket=options['s3_bucket'],
                                     Key=item['Key'])
                print(' Done!')


def get_client(options, client_type):
    session = boto3.Session(profile_name=options['aws_profile_name'])
    if client_type == 'acm':
        client = session.client(client_type, region_name='us-east-1')
    else:
        client = session.client(client_type)
    return client


if __name__ == '__main__':

    import tools

    parser = argparse.ArgumentParser()
    parser.add_argument('--data', help='YAML data file', required=True)
    parser.add_argument('--clean',
                        help=('Clean AWS Bucket (excluding images)'
                              ' before uploading'),
                        action='store_true')
    parser.add_argument('--check', help='Check s3 and cloudfront settings',
                        action='store_true')
    args = parser.parse_args()
    data = tools.load_yaml(args.data)

    s3_client = get_client(data['options'], 's3')

    if args.clean:
        print(f'\n\n#####\nCleaning s3://{data["options"]["s3_bucket"]}...')
        clean(data['options'], client=s3_client)
        print('All Clean!\n\n')

    if not args.check:
        print((f'#####\nUploading {data["options"]["dist"]}'),
              (f'to {data["options"]["s3_bucket"]}...'))
        send_it(data['options'])
        print('Done!')

    print('\n#####\nWebsite Settings:')
    check_cdn_distribution(data['options'])
    # confirm_website_settings(data['options'], s3_client)
    # check_bucket_policy(data['options'], s3_client)
    print('\n#####')
